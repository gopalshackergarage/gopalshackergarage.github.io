{"data":{"site":{"siteMetadata":{"title":"The Hacker Garage","subtitle":"So excited about this craft that, I can't keep myself from blogging about it","copyright":"© All rights reserved.","author":{"name":"Gopal S Akshintala","twitter":"http://bit.ly/agstwtr","github":"http://bit.ly/agsgithub","linkedin":"http://bit.ly/agslnkd","telegram":"https://t.me/gopalakshintala","email":"gopal.akshintala@gmail.com","rss":"#"},"disqusShortname":"gopal","url":"https://github.com/gopalshackergarage/gopalshackergarage.github.io"}},"markdownRemark":{"id":"6df4d213-9a4a-5890-823a-ac5962031587","html":"<p>All the popular Design Patterns abridged for quick revision, along with some tidbits.</p>\n<h2>Creational Patterns</h2>\n<h3>Factory method Vs Abstract Factory</h3>\n<ul>\n<li>Abstract factory has a level more depth of abstraction.</li>\n<li>Factory method abstracts creation of a family of objects.</li>\n<li>Abstract factory does the same, but inside, the product depends on an abstract factory which can be assigned any of the family of factories. </li>\n<li>This abstract factory is ‘composed’ (HAS-A) inside factory.</li>\n<li>Abstract Factory is one level higher in abstraction than Factory Method. Factory Method abstracts the way objects are created, while Abstract Factory abstracts the way factories are created which in turn abstracts the way objects are created.</li>\n</ul>\n<h3>Builder Pattern</h3>\n<ul>\n<li>When the parameters involved in construction of an object are dynamic and inconsistent in terms of optional/required, passing null for optionals or having multiple constructors can get dirty.</li>\n<li>Instead, a ‘builder’ class, which HAS-A the object to build, can be made responsible of creation.</li>\n<li>This can be achieved by fluent methods inside builder class, which act like setter methods on the object to be created.</li>\n</ul>\n<h2>Behavioral Patterns</h2>\n<h3>Strategy Pattern</h3>\n<ul>\n<li>“Encapsulate what varies”, use HAS-A over IS-A.</li>\n<li>Behavior encapsulated into an object which is used HAS-A. This can be dynamically changed to change behavior of the object.</li>\n<li>This is called Runtime Sub-classing or Runtime Polymorphism.</li>\n<li>This is alternative to sub-classing</li>\n</ul>\n<h3>Observer pattern</h3>\n<ul>\n<li>Observer objects are registered in a HAS-A fashion.</li>\n<li>All observers implement same interface that contain the notify or callback method.</li>\n<li>This encourages loose coupling.</li>\n</ul>\n<h3>Command Pattern</h3>\n<ul>\n<li>Encapsulates request or command as an object.</li>\n<li>To decouple client from receiver Invocation, the request/command object is given to invoker, instead of directly invoking it on the receiver.</li>\n<li>It helps in Queueing, logging requests etc.</li>\n<li>Command object HAS-A receiver which calls methods on receiver. Client just has to call invoker.execute();</li>\n</ul>\n<h3>Template Method Pattern</h3>\n<ul>\n<li>It defines the skeleton of algorithm, deferring some steps to sub-classes to define or redefine, without changing algorithm structure.</li>\n<li>It can also contain methods called ‘Hooks’, to provide default implementation of a method common to all classes.</li>\n<li>In template, client can depend on higher abstract class. It has control over algorithm and calls to subclasses only when there is a need to implement a method.</li>\n<li>This is a great design tool for creating <em>Frameworks</em>.</li>\n</ul>\n<h3>Iterator Pattern</h3>\n<ul>\n<li>Provides a way to iterate through a aggregate collection of objects.</li>\n<li>The Iterator object consists of methods that takes care of looping through the collection.</li>\n<li>Underlying representation of collection (be it array or arrayList or HashMap) is hidden from client.</li>\n</ul>\n<h3>Composite Pattern</h3>\n<ul>\n<li>It deals with 2 responsibilities: <em>Iterating</em> and <em>Uniformity</em>.</li>\n<li>Allows objects to compose objects into tree structure to represent <em>Part-Whole</em> hierarchies.</li>\n<li>It lets client treat both individual objects and composite objects the same way.</li>\n<li>SRP (Single Responsibility Principle) is violated for Transparency.</li>\n</ul>\n<h3>State Pattern</h3>\n<ul>\n<li>The behavior of an object depends on its state.</li>\n<li>State is controlled and switched using a HAS-A object.</li>\n<li>It smells like <em>Strategy Pattern</em> but they differ in intent.</li>\n<li>Strategy pattern is an alternate for Sub-Classing while State pattern is an alternative to having if-else conditions everywhere and encapsulating behavior to state object.</li>\n</ul>\n<h2>Structural Patterns</h2>\n<h3>Decorator Pattern</h3>\n<ul>\n<li>“Open-Closed” Principle. Open for extension and closed for change.</li>\n<li>This is used to achieve “Dynamic Inheritance”.</li>\n<li>A component is given to Decorator object as HAS-A and Decorator class adds extra functionality or responsibility to it.</li>\n<li>Both component and Decorator implement the same interface. So one decorator can be component to another decorator, thus behavior can be added in layers or wrappers.</li>\n</ul>\n<h3>Adapter Pattern</h3>\n<ul>\n<li>Converts one interface to another (Target), adaptable to client.</li>\n<li>It is done by implementing ‘Target’ interface and HAS-A Adoptee object. Now client calls methods on Adapter and it delegates appropriately to Adoptee.</li>\n<li>Decorator, Adapter and Facade patterns are close but differ in their intent.</li>\n</ul>\n<h3>Bridge Pattern</h3>\n<ul>\n<li>This is similar to Adapter pattern, except that it bridges between two hierachies of abstractions.</li>\n<li>It has two layers abstractions, one that holds the interface methods for client and the other abstraction is what actual implementations extend.</li>\n<li>Abstraction for client HAS-A implementor abstraction for delegation.</li>\n<li>This provides flexibility for both these hierarchies to independently change.</li>\n<li>This has downside of increasing complexity.</li>\n</ul>\n<h3>Facade Pattern</h3>\n<ul>\n<li>It’s an unified interface, that a client can use with ease to control many other sub-systems.</li>\n<li>A facade HAS-A all other components of sub-systems references and makes use of them appropriately.</li>\n<li>If there are too many sub-systems for one Facade to handle, we can multiple layers of Facade.</li>\n</ul>\n<h3>Proxy Pattern</h3>\n<ul>\n<li>It provides a surrogate or placeholder for another object to control access to it.</li>\n<li>The local stub has the same API as original object. Once client invokes any method on stub, it requests the state of original object and provides it to the client.</li>\n</ul>\n<h3>Decorator vs Adapter vs Facade</h3>\n<ul>\n<li>Decorator: Adds responsibility without the change of interface.</li>\n<li>Adapter: Converts on interface to another.</li>\n<li>Facade: Simplify an interface.</li>\n</ul>\n<h2>Bonus</h2>\n<h3>Principle of Least knowledge (or) Law of Delimiter</h3>\n<ul>\n<li>One should make calls only to its immediate objects. Otherwise, it builds unnecessary dependencies between objects and makes the system fragile and complex to understand.</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">station<span class=\"token punctuation\">.</span><span class=\"token function\">getThermometer</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getTemp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Wrong approach</span>\nstation<span class=\"token punctuation\">.</span><span class=\"token function\">getTemp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token comment\">// Right approach</span></code></pre></div>\n<ul>\n<li>But we can call methods on objects we pass or create in any local methods.</li>\n<li>However, this results in more ‘wrapper’ classes being written.</li>\n<li>The same is followed in Facade pattern, client only interacts with its immediate Facade object.</li>\n</ul>\n<h3>Hollywood Principle</h3>\n<ul>\n<li>Always higher level components should call lower-level ones.</li>\n</ul>\n<h3>MVC Pattern</h3>\n<ul>\n<li>View and Controller together implement <em>Strategy Pattern</em>.</li>\n<li>View depends on controller for user actions, so view behavior depends on Controller. Now, this controller can be easily replaced with another to change behavior.</li>\n</ul>","fields":{"tagSlugs":["/tags/design/"]},"frontmatter":{"title":"Pocket Design Patterns","tags":["Design"],"date":"2018-04-14T00:00:00.000Z","description":"All the popular Design Patterns abridged for quick revision, along with some tidbits."}}},"pageContext":{"slug":"/posts/pocket-design-patterns/"}}