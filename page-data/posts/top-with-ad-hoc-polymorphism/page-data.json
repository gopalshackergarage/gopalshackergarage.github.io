{"componentChunkName":"component---src-templates-post-template-jsx","path":"/posts/top-with-ad-hoc-polymorphism/","result":{"data":{"site":{"siteMetadata":{"title":"It's All Over full-stack","subtitle":"So excited about this Craft that, I can't keep myself from blogging about it.","copyright":"¬© All rights reserved.","declaration":"I built this blog with React.js","author":{"name":"Gopal S Akshintala","twitter":"http://bit.ly/agstwtr","github":"http://bit.ly/agsgithub","linkedin":"http://bit.ly/agslnkd","telegram":"https://t.me/gopalakshintala","email":"gopal.akshintala@gmail.com","stackoverflow":"http://bit.ly/agsso","aboutme":"/about-me"},"disqusShortname":"gopal","url":"https://github.com/overfullstack/overfullstack.github.io"}},"markdownRemark":{"id":"337b887a-006f-52e4-8601-78245f20d778","html":"<h2 id=\"Abstract\" style=\"position:relative;\">Abstract<a href=\"#Abstract\" aria-label=\"Abstract permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>With the advent of B2C products, the same product can have use-cases (or Services) with varied traffic and scaling needs. The trend is to split them into Microservices built on different paradigms/tech-stacks (blocking or non-blocking [1]). In domains like Payments, many such heterogeneous services are parallel as well (having most of the domain business logic in common e.g., Purchases and Refunds). Although the business logic is common, it cannot be reused among these parallel services, as the code is written specifically to that paradigm.</p>\n<p>This paper attempts to overcome this challenge and make such common logic <strong>reusable</strong>, turning the <code>Monomorphic</code> common code to <code>Polymorphic</code> templates, using an innovative design technique called <code>Ad-hoc Polymorphism</code>.</p>\n<h2 id=\"Things-to-know-before-reading\" style=\"position:relative;\">Things to know before reading<a href=\"#Things-to-know-before-reading\" aria-label=\"Things to know before reading permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>A good understanding of generics and exposure to blocking/non-blocking paradigms. This is language-agnostic, but the I will use <strong>Kotlin</strong> (a modern JVM language) for demonstration along with <strong>Arrow</strong> (An upcoming Functional Programming library for Kotlin).</p>\n<h2 id=\"The-Case-for-Heterogeneous-services\" style=\"position:relative;\">The Case for Heterogeneous services<a href=\"#The-Case-for-Heterogeneous-services\" aria-label=\"The Case for Heterogeneous services permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Taking the example from Payments domain, <strong>Purchases</strong> tend to have high traffic (especially during Black Fridays, Flash sales, etc), and it's common to model them with an Asynchronous non-blocking paradigm like <strong>Reactive Stack</strong> [2]. Whereas, <strong>Refunds</strong> tend to have relatively low traffic and its scaling needs can easily be catered with a simple blocking stack.</p>\n<h2 id=\"Problem-of-Reusability-among-Heterogeneous-services\" style=\"position:relative;\">Problem of Reusability among Heterogeneous services<a href=\"#Problem-of-Reusability-among-Heterogeneous-services\" aria-label=\"Problem of Reusability among Heterogeneous services permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Despite being heterogenous, these services have a lot of commonality in their Domain logic - like Authentication, Request-Validation, Idempotency, external integrations (like gateway interaction), logging, etc. In the case of homogeneous services, this reusable code can be placed in a different module and be added as a dependency in all services. But in heterogeneous case, blocking code can't be reused for non-blocking service or vice-versa, because:</p>\n<ul>\n<li>Their styles of programming are different (Functional in non-blocking vs Imperative in blocking).</li>\n<li>Non-Blocking code is filled with callbacks while the blocking code is sequential.</li>\n<li>The DB APIs are different, as non-blocking services use non-blocking DBs.</li>\n<li>Each paradigm has specific <code>Effect (or Container)</code> it operates on, e.g - Non-blocking paradigms operate on reactive containers like <code>Mono&#x3C;A>/Flux&#x3C;A> or Observable&#x3C;A></code>, contrary to blocking paradigms which may (or need not) use simple containers like <code>Option/Either</code>.</li>\n</ul>\n<p>Due to this problem, the code is rewritten or duplicated for common use-cases, which eventually leads to maintenance overhead. This also applies to services that have future plans to migrate to async non-blocking as their business increases, in which case, the entire service needs to be rewritten although the domain business logic remains the same.</p>\n<h2 id=\"Monomorphic-to-Polymorphic\" style=\"position:relative;\">Monomorphic to Polymorphic<a href=\"#Monomorphic-to-Polymorphic\" aria-label=\"Monomorphic to Polymorphic permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Monomorphic code is written specifically to the <code>Effect (or Container)</code>. If the Effect is abstracted out as a <em>Generic</em>, the domain logic turns reusable for any type of service, and it can be called <strong>Polymorphic</strong>. But to achieve that, we need to understand concepts like <strong>TypeClasses</strong> and <strong>Higher-Kinds</strong>.</p>\n<p>But let's briefly touch upon types of Polymorphism:</p>\n<h3 id=\"Subtype-Polymorphism-Inheritance-3\" style=\"position:relative;\">Subtype Polymorphism (Inheritance) [3]<a href=\"#Subtype-Polymorphism-Inheritance-3\" aria-label=\"Subtype Polymorphism Inheritance 3 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>This is the most common OOP pattern, where we achieve polymorphism through inheritance. An interface is implemented by multiple classes (called subtypes).</p>\n<h3 id=\"Parametric-Polymorphism-Generics-4\" style=\"position:relative;\">Parametric Polymorphism (Generics) [4]<a href=\"#Parametric-Polymorphism-Generics-4\" aria-label=\"Parametric Polymorphism Generics 4 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Simply put, this style uses generics (like <code>&#x3C;T></code>), to generate templates of reusable code. This works when the logic doesn't depend on any type-specific behavior. e.g., <code>Array&#x3C;T></code>.</p>\n<h3 id=\"Ad-hoc-Polymorphism-Type-Classes-5\" style=\"position:relative;\">Ad-hoc Polymorphism (Type Classes) [5]<a href=\"#Ad-hoc-Polymorphism-Type-Classes-5\" aria-label=\"Ad hoc Polymorphism Type Classes 5 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>The term <strong>Ad-hoc polymorphism</strong> refers to polymorphic functions that can be applied to arguments of different types, but that behave differently depending on the type of the argument to which they are applied. To achieve this, we use <strong>TypeClasses</strong>. <code>Comparator&#x3C;T></code> in JDK is a simple typeClass. TypeClasses are just generic interfaces that are parametric on a Type <code>T</code>. </p>\n<h2 id=\"TypeClass\" style=\"position:relative;\">TypeClass<a href=\"#TypeClass\" aria-label=\"TypeClass permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>A type class <code>C</code> defines some behavior in the form of operations that must be supported by a type <code>T</code> for it to be a member of type class <code>C</code>. A type can be a member of a type class simply by providing implementations of the operations the type must support. Once <code>T</code> is made a member of the type class <code>C</code>, functions that have constrained one or more of their parameters to be members of <code>C</code> can be called with arguments of type <code>T</code>.\n<code>Comparator&#x3C;T></code> has one operation <code>fun compare(a: T?, b: T?): Int</code>. Now for a type <code>Apple</code> to be a member of this TypeClass, prepare a concrete <code>Comparator&#x3C;Apple></code> implementing its <code>fun compare(a: Apple?, b: Apple?): Int</code>. That's it! Now the JDK's <code>Collections.sort()</code> can make use of this concrete implementation to compare apples.\nThe code that relies on type classes is open for extension. Just like how <code>Comparator&#x3C;T></code> can be extended to compare any type.</p>\n<h3 id=\"Need-for-Higher-Kinded-Types-6\" style=\"position:relative;\">Need for Higher-Kinded Types [6]<a href=\"#Need-for-Higher-Kinded-Types-6\" aria-label=\"Need for Higher Kinded Types 6 permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h3>\n<p>Effects are of the form <code>F&#x3C;A></code> (e.g. <code>Mono&#x3C;A></code>), where <code>F</code> is the container type and <code>A</code> is the value type. The problem is, most JVM languages only support parametricity on the value type <code>A</code> but not on the Container type <code>F</code>. So to represent it, we need <strong>Higher-Kinded Types</strong>, which are represented by <code>Kind&#x3C;F, A></code> which is synonymous to <code>F&#x3C;A></code></p>\n<h2 id=\"Ad-hoc-Polymorphism-by-example\" style=\"position:relative;\">Ad-hoc Polymorphism by example<a href=\"#Ad-hoc-Polymorphism-by-example\" aria-label=\"Ad hoc Polymorphism by example permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Now that we have both the tools (TypeClasses and Higher-Kinded Types), let‚Äôs make a polymorphic template for our reusable domain logic. A POC working sample can be found in this <a href=\"https://github.com/overfullstack/ad-hoc-poly\">GitHub repo</a>. I shall be using references from this code to explain the subsequent examples, where we have two identical services, one built with <code>Spring-WebFlux</code> (non-blocking reactive stack) [7] and another built with <code>Spring-WebMVC</code> (blocking servlet stack) [8]. We shall take-up the <em>user validate-and-upsert</em> as our example use-case (where a request to upsert a user is validated and either inserted or updated based on the user's existence in the DB). We shall attempt to abstract this into a common module so that both the services can consume it.</p>\n<ul>\n<li><code>Spring-WebFlux</code> works with <code>Mono&#x3C;A>/Flux&#x3C;A></code> while <code>Spring-WebMVC</code> doesn't. Also, we shall see how the difference in paradigms prevents reusability.</li>\n<li>The first step, is to abstract the DB behavior in both these stacks to a generic TypeClass interface, <code>RepoTC&#x3C;F></code>, where <code>F</code> represents the Effect-type on which the DB works in their respective stacks. This is how the simplest version of it looks like:</li>\n</ul>\n<pre><code class=\"language-kotlin:title=RepoTC.kt\">interface RepoTC&#x3C;F> : Async&#x3C;F> {\n    fun User.get(): Kind&#x3C;F, User?>\n}\n</code></pre>\n<p>This code may look alien at first, but if we get into the details it all makes sense.</p>\n<ul>\n<li>The operation <code>get()</code> has a return type <code>Kind&#x3C;F, User?></code>, which is synonymous to <code>F&#x3C;User?></code>. This indicates our operations are agnostic of <code>Effect</code>.</li>\n<li>Our <code>RepoTC&#x3C;F></code> extends from <code>Async&#x3C;F></code> which is TypeClass from <em>Arrow</em> library.</li>\n<li>Our Services are supposed to supply concrete instances of this <code>RepoTC&#x3C;F></code> and provide implementation for its operation <code>get()</code>.</li>\n<li>We can help our services to map their <em>Effect-full</em> operations to generic operations, for which we can write two utility functions, which are extension functions on <code>Async&#x3C;F></code> as below:</li>\n</ul>\n<pre><code class=\"language-kotlin:title=RepoUtils\">fun &#x3C;R> forMono(thunk: () -> Mono&#x3C;R>): Kind&#x3C;F, R?> = effect { thunk().k().suspended() }\nfun &#x3C;R> forIO(thunk: () -> R): Kind&#x3C;F, R> = effect { thunk() }\n</code></pre>\n<ul>\n<li>The <code>Async&#x3C;F></code> typeClass has an important method called <code>effect{..}</code>, which wraps a function with an <em>Effect</em> return type (like <code>Mono&#x3C;F></code>) and returns a generic effect type <code>Kind&#x3C;F, A></code>.</li>\n<li>Utilizing these utilities, Just like <code>Comparator&#x3C;T></code> example we discussed, we can create two concrete instances of our <code>Repo&#x3C;TC></code> - <code>blockingRepo</code>, <code>nonBlockingReactiveRepo</code>.</li>\n</ul>\n<pre><code class=\"language-kotlin:title=ConcreteInstances\">val blockingRepo = object : RepoTC&#x3C;ForIO>, Async&#x3C;ForIO> by IO.async() {\n    override fun User.get(): Kind&#x3C;ForIO, User?> = forIO { userRepo.findOne(loginId) }\n}\n\nval nonBlockingReactiveRepo = object : RepoTC&#x3C;ForMonoK>, Async&#x3C;ForMonoK> by MonoK.async() {\n    override fun User.get(): Kind&#x3C;ForMonoK, User?> = forMono { userReactiveRepo.findOne(loginId) }\n}\n</code></pre>\n<ul>\n<li>For blocking operations, <code>IO.async()</code> instance is supplied as implementation for <code>Async&#x3C;F></code> and for non-blocking operations, <code>MonoK.async()</code> is supplied. These concrete instances effect the <code>effect{..}</code> method's behavior and supplies it with superpowers to handle a specified effect (<code>Mono</code> or <code>IO</code>).</li>\n<li>The return types of <code>userRepo.findOne(loginId)</code> is <code>User?</code> and <code>userReactiveRepo.findOne(loginId)</code> is <code>Mono&#x3C;User?></code>, both these are mapped to generic function <code>User.get()</code> whose return type is a higher-kind <code>Kind&#x3C;F, User?></code> where <code>F</code> is represented by <code>ForMonK</code> and <code>ForIO</code> in their respective concrete entities.</li>\n</ul>\n<h2 id=\"How-the-pieces-fit\" style=\"position:relative;\">How the pieces fit?<a href=\"#How-the-pieces-fit\" aria-label=\"How the pieces fit permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ul>\n<li>This typeClass <code>RepoTC&#x3C;F></code> is the bridge between the service and common module (In the GitHub repo, this common module is named as <code>validation-fx</code>).</li>\n<li><code>RepoTC&#x3C;F></code> has all the common business logic template (refer <code>validateUserForUpsert</code> function <a href=\"https://github.com/overfullstack/ad-hoc-poly/blob/master/validation-fx/src/main/kotlin/com/validation/RepoTC.kt#L32\">here</a>). Arrow's <code>fx</code> blocks are used to write this code, which shall be briefly explained in the talk.</li>\n<li>These templates depend on the TypeClass's abstract functions (like <code>get()</code>) to weave their business logic. As shown in <a href=\"https://github.com/overfullstack/ad-hoc-poly/blob/master/validation-fx/src/main/kotlin/com/validation/RepoTC.kt#L13\">this code</a>, the <code>RepoTC&#x3C;F></code> can be extended with more DB operations to be used inside our templates.</li>\n<li>On the service side, we supply concrete implementation of TypeClasses as a dependency (Refer <a href=\"https://github.com/overfullstack/ad-hoc-poly/blob/master/kofu-mvc-validation/src/main/kotlin/com/sample/Configurations.kt#L29\">this</a> and <a href=\"https://github.com/overfullstack/ad-hoc-poly/blob/master/kofu-reactive-validation/src/main/kotlin/com/sample/Configurations.kt#L20\">this</a>).</li>\n<li>Now both services can consume the common business logic through these concrete entities (Refer <a href=\"https://github.com/overfullstack/ad-hoc-poly/blob/master/kofu-mvc-validation/src/main/kotlin/com/sample/Handlers.kt#L84\">this</a> and <a href=\"https://github.com/overfullstack/ad-hoc-poly/blob/master/kofu-reactive-validation/src/main/kotlin/com/sample/Handlers.kt#L97\">this</a>).</li>\n</ul>\n<h2 id=\"Outcomes-and-Conclusions\" style=\"position:relative;\">Outcomes and Conclusions<a href=\"#Outcomes-and-Conclusions\" aria-label=\"Outcomes and Conclusions permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>We achieved reusable domain logic using Ad-hoc Polymorphism, abstracting out the effect using TypeClasses and Higher-Kinded Types, migrating our Monomorphic code to Polymorphic. This is very powerful to model B2C-services and to-be-scalable services. This <strong>zeros-down the cost and effort</strong> to rewrite and maintain common business logic across all parallel services and future service migrations, speeding-up the feature development.</p>\n<h2 id=\"References\" style=\"position:relative;\">References<a href=\"#References\" aria-label=\"References permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li><a href=\"https://community.oracle.com/docs/DOC-918126\">https://community.oracle.com/docs/DOC-918126</a></li>\n<li><a href=\"https://www.reactivemanifesto.org/\">https://www.reactivemanifesto.org/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Subtyping\">https://en.wikipedia.org/wiki/Subtyping</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Parametric_polymorphism\">https://en.wikipedia.org/wiki/Parametric_polymorphism</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Ad_hoc_polymorphism\">https://en.wikipedia.org/wiki/Ad<em>hoc</em>polymorphism</a></li>\n<li><a href=\"https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf\">https://www.cl.cam.ac.uk/~jdy22/papers/lightweight-higher-kinded-polymorphism.pdf</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html\">https://docs.spring.io/spring/docs/current/spring-framework-reference/web-reactive.html</a></li>\n<li><a href=\"https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#spring-web\">https://docs.spring.io/spring/docs/current/spring-framework-reference/web.html#spring-web</a></li>\n<li><a href=\"https://danielwestheide.com/blog/the-neophytes-guide-to-scala-part-12-type-classes/\">https://danielwestheide.com/blog/the-neophytes-guide-to-scala-part-12-type-classes/</a></li>\n</ol>","timeToRead":10,"fields":{"tagSlugs":["/tags/kotlin/","/tags/arrow/"],"slug":"/posts/top-with-ad-hoc-polymorphism/"},"frontmatter":{"title":"Template-Oriented-Programming (TOP) with Ad-Hoc Polymorphism","tags":["Kotlin","Arrow"],"date":"2020-03-06T00:00:00.000Z","description":"Top-up the Polymorphism","cover":{"childImageSharp":{"original":{"src":"/static/cover-9a40c4ec97d54bd9903dfb33033e2724.jpeg"}}}}}},"pageContext":{"slug":"/posts/top-with-ad-hoc-polymorphism/","previous":{"fields":{"slug":"/posts/monads-for-drunken-coders-pint-1/"},"frontmatter":{"title":"Monads for Drunken Coders, Pint-1üç∫","tags":["Java 8","Monads"],"layout":"post","category":"Functional Programming"}},"next":null}}}